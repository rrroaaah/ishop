// Mizoon Theme Scripts
// Auto-generated file


// File: article\script.js


// File: baner-mobile\script.js


// File: basic\script.js


// File: biography\script.js


// File: card-brand\script.js


// File: card-tooltip\script.js


// File: certificate-of-appreciation\script.js


// File: commodity-pack\script.js


// File: contact-us\script.js


// File: copy\script.js
class CopyAddress {
    constructor(selector = '.copy-address') {
      this.items = document.querySelectorAll(selector);
      this.init();
    }
  
    init() {
      this.items.forEach(wrapper => {
        const copyBtn = wrapper.querySelector('.copy-item');
        const urlEl = wrapper.querySelector('.site-url');
  
        if (!copyBtn || !urlEl) return;
  
        const url = window.location.href;
  
        urlEl.textContent = url;
  
        copyBtn.addEventListener('click', () => {
          this.copyToClipboard(url, copyBtn);
        });
      });
    }
  
    copyToClipboard(text, button) {
      navigator.clipboard.writeText(text).then(() => {
        this.onSuccess(button);
      }).catch(() => {
        this.onError(button);
      });
    }
  
  }
  
new CopyAddress();

// File: countdown\script.js
class Countdown {
  static UNITS = ['seconds', 'minutes', 'hours', 'days'];
  static DEFAULT_SEPARATOR = ':';
  static INTERVAL = 1000;

  constructor(element, options = {}) {
    this.element = element;
    this.separator = options.separator || Countdown.DEFAULT_SEPARATOR;
    this.parts = (element.dataset.countdown || '0').split(':').map(Number).reverse();
    this.unitCount = this.parts.length;
    this.totalSeconds = this.toSeconds(this.parts);
    this.timer = null;

    this.build();
    this.start();
  }

  // --- Helpers ---
  toSeconds([seconds = 0, minutes = 0, hours = 0, days = 0]) {
    return seconds + minutes * 60 + hours * 3600 + days * 86400;
  }

  fromSeconds(total) {
    const limits = [60, 60, 24, Infinity];
    return limits.map(limit => {
      const value = total % limit;
      total = Math.floor(total / limit);
      return value;
    });
  }

  createSeparator() {
    const sep = document.createElement('span');
    sep.className = 'countdown-separator';
    sep.textContent = this.separator;
    return sep;
  }

  createItem(value, unit) {
    const item = document.createElement('div');
    item.className = `countdown-item ${unit}`;
    String(value).padStart(2, '0').split('').forEach(digit => {
      const span = document.createElement('span');
      span.className = 'fields';
      span.textContent = digit;
      item.appendChild(span);
    });
    return item;
  }

  // --- Build DOM ---
  build() {
    this.element.innerHTML = '';
    this.parts.forEach((value, index) => {
      const unit = Countdown.UNITS[index];
      if (!unit) return;
      this.element.appendChild(this.createItem(value, unit));
      if (index < this.unitCount - 1) this.element.appendChild(this.createSeparator());
    });
  }

  // --- Update DOM ---
  update(values) {
    this.element.querySelectorAll('.countdown-item').forEach((item, index) => {
      String(values[index]).padStart(2, '0').split('').forEach((digit, i) => {
        item.querySelectorAll('.fields')[i].textContent = digit;
      });
    });
  }

  // --- Timer ---
  tick() {
    if (this.totalSeconds <= 0) {
      clearInterval(this.timer);
      return;
    }
    this.totalSeconds--;
    this.update(this.fromSeconds(this.totalSeconds));
  }

  start() {
    this.timer = setInterval(() => this.tick(), Countdown.INTERVAL);
  }

  pause() {
    clearInterval(this.timer);
    this.timer = null;
  }

  resume() {
    if (!this.timer) this.start();
  }
}

// Auto-init
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.countdown[data-countdown]').forEach(el => new Countdown(el));
});


// File: devicebanner\script.js


// File: faq\script.js
class Accordion {
    constructor() {
        this.accordionItems = document.querySelectorAll('.accordion');
        this.init();
    }

    init() {
        this.accordionItems.forEach(item => {
            item.addEventListener('click', (event) => this.handleAccordionClick(event));
        });
    }

    handleAccordionClick(event) {
        const clickedItem = event.currentTarget;
        const parentElement = clickedItem.parentElement;
        const siblings = parentElement.querySelectorAll('.accordion');

        if (this.isIndependent(clickedItem)) {
            this.toggleAccordion(clickedItem);
            return;
        }

        this.closeOtherAccordions(siblings, clickedItem);
        this.toggleAccordion(clickedItem);
    }

    isIndependent(item) {
        return item.classList.contains('accordion-absolute');
    }

    toggleAccordion(item) {
        item.classList.toggle('active');
    }

    closeOtherAccordions(siblings, currentItem) {
        siblings.forEach(sibling => {
            if (sibling !== currentItem && !this.isIndependent(sibling)) {
                sibling.classList.remove('active');
            }
        });
    }
}

// Initialize accordion when DOM is loaded
new Accordion();

// File: feature-description-box\script.js


// File: header-submenu\script.js
class ScrollHeader {
  constructor() {
    this.header = document.querySelector('.secondary-part');
    this.lastScroll = 0;
    this.offset = 100;
    this.init();
  }

  init() {
    if (!this.header) return;
    window.addEventListener('scroll', () => this.onScroll());
  }

  onScroll() {
    const currentScroll = window.pageYOffset || document.documentElement.scrollTop;

    if (currentScroll > this.lastScroll && currentScroll > this.offset) {
      this.hide();
    } else {
      this.show();
    }

    this.lastScroll = currentScroll <= 0 ? 0 : currentScroll;
  }

  hide() {
    this.header.classList.add('hide-submenu');
  }

  show() {
    this.header.classList.remove('hide-submenu');
  }
}
 new ScrollHeader();
// File: forign-product\script.js


// File: logo-banner\script.js


// File: more-discounts-tooltip\script.js


// File: product-button-feature\script.js


// File: product-card\script.js


// File: product-category\script.js
const productsCategory = document.querySelectorAll(".product-category");

productsCategory.forEach(category => {
    category.addEventListener("click" , () => {
        productsCategory.forEach(active => active.classList.remove("active"));

        category.classList.add("active");
    });
});

// File: product-comment\script.js


// File: product-details\script.js


// File: product-gallery-image\script.js
class ProductHover {
    constructor(selector = '.product-gallery .slider-content') {
      this.items = document.querySelectorAll(selector);
      this.init();
    }
  
    init() {
      this.items.forEach(wrapper => {
        const img = wrapper.querySelector('img');
        if (!img) return;
  
        wrapper.addEventListener('mousemove', e => {
          this.onMove(e, wrapper, img);
        });
  
        wrapper.addEventListener('mouseleave', () => {
          this.onLeave(img);
        });
      });
    }
  
    onMove(e, wrapper, img) {
      const rect = wrapper.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 100;
      const y = ((e.clientY - rect.top) / rect.height) * 100;
  
      img.style.transformOrigin = `${x}% ${y}%`;
      img.style.transform = 'scale(2)';
    }
  
    onLeave(img) {
      img.style.transformOrigin = 'center';
      img.style.transform = 'scale(1)';
    }
}

new ProductHover();

// File: product-gallery-slider\script.js


// File: product-qa\script.js


// File: product-specifications\script.js


// File: product-toolbar\script.js


// File: progress\script.js
class ProgressBar {
    constructor() {
        this.init();
    }

    init() {
        document.querySelectorAll('.progress-bar').forEach(bar => {
            const percentage = bar.dataset.progressPercentage;
            const duration = bar.dataset.progressDuration;
            const delay = bar.dataset.progressDelay;

            if (percentage) {
                bar.style.setProperty('--percentage', percentage);
            }

            if (duration) {
                bar.style.setProperty('--progress-animation-duration', duration);
            }

            if (delay) {
                bar.style.setProperty('--progress-animation-delay', delay);
            }
        });
    }
}

new ProgressBar();

// File: rating-card\script.js


// File: return-conditions\script.js


// File: single-product-content\script.js
class SectionScroller {
    constructor(options) {
        this.upArrow = document.querySelector(options.upArrowSelector);
        this.downArrow = document.querySelector(options.downArrowSelector);
        this.titles = document.querySelectorAll(options.titleSelector);
        this.sections = options.sectionIds.map(id => document.getElementById(id));
        this.currentIndex = 0;

        this.init();
    }

    init() {
        this.updateTitle(this.currentIndex);
        this.bindEvents();
    }

    bindEvents() {
        this.upArrow.addEventListener("click", () => this.scrollToSection(this.currentIndex - 1));
        this.downArrow.addEventListener("click", () => this.scrollToSection(this.currentIndex + 1));

        window.addEventListener("scroll", () => this.onScroll());
    }

    updateTitle(index) {
        this.titles.forEach((h3, i) => h3.classList.toggle("active", i === index));
    }

    scrollToSection(index) {
        if (index < 0) index = 0;
        if (index >= this.sections.length) index = this.sections.length - 1;

        this.sections[index].scrollIntoView({ behavior: "smooth" });
        this.currentIndex = index;
        this.updateTitle(this.currentIndex);
    }

    onScroll() {
        const scrollPos = window.scrollY + window.innerHeight / 2;
        this.sections.forEach((section, idx) => {
            if (section.offsetTop <= scrollPos) {
                this.currentIndex = idx;
                this.updateTitle(this.currentIndex);
            }
        });
    }
}

document.addEventListener("DOMContentLoaded", () => {
    const scroller = new SectionScroller({
        upArrowSelector: ".arrow-controls .fa-angle-up",
        downArrowSelector: ".arrow-controls .fa-angle-down",
        titleSelector: ".slider-frame h3",
        sectionIds: ["description-link", "description-completed", "comented-link", "question-link"]
    });
});


// File: slider\script.js
// class Slider {
//     constructor(selector = ".slider") {
//         this.instances = [];
//         document.querySelectorAll(selector).forEach(slider => {
//             this.instances.push(this.createInstance(slider));
//         });
//     }

//     createInstance(slider) {
//         const instance = {
//             container: slider,
//             wrapper: slider.querySelector(".slider-wrapper"),
//             track: slider.querySelector(".slider-container"),
//             slides: Array.from(slider.querySelectorAll(".slider-content")),
//             toggles: slider.querySelectorAll(".slider-toggle"),
//             nextArrow: slider.querySelector(".slider-arrow-next"),
//             prevArrow: slider.querySelector(".slider-arrow-prev"),

//             current: 0,
//             startX: 0,
//             isDragging: false,
//             autoplayTimer: null,

//             isVertical: false,
//             isLoop: false,
//             isRTL: false,
//             autoplayDelay: null,

//             init() {
//                 this.isVertical = this.wrapper.classList.contains("slider-column");
//                 this.isLoop = this.wrapper.classList.contains("slider-loop");
//                 this.isRTL = getComputedStyle(this.container).direction === "rtl";

//                 this.autoplayDelay = this.container.dataset.sliderTimer
//                     ? parseInt(this.container.dataset.sliderTimer)
//                     : null;

//                 const activeIndex = this.slides.findIndex(s => s.classList.contains("active"));
//                 this.current = activeIndex >= 0 ? activeIndex : 0;

//                 this.bindEvents();
//                 this.update();
//                 this.initAutoplay();
//             },

//             /* ---------- core ---------- */

//             update() {
//                 let value = this.current * 100;
//                 if (!this.isVertical && this.isRTL) value *= -1;

//                 this.track.style.transform = this.isVertical
//                     ? `translateY(-${value}%)`
//                     : `translateX(-${value}%)`;

//                 this.slides.forEach(s => s.classList.remove("active"));
//                 this.slides[this.current].classList.add("active");

//                 this.toggles.forEach(t => t.classList.remove("active"));
//                 const t = this.container.querySelector(
//                     `.slider-toggle[data-slider-id="${this.slides[this.current].id}"]`
//                 );
//                 t?.classList.add("active");

//                 this.updateArrows();
//             },

//             updateArrows() {
//                 if (!this.prevArrow || !this.nextArrow || this.isLoop) return;

//                 this.prevArrow.classList.toggle("disabled", this.current === 0);
//                 this.nextArrow.classList.toggle(
//                     "disabled",
//                     this.current === this.slides.length - 1
//                 );
//             },

//             next() {
//                 if (this.current < this.slides.length - 1) this.current++;
//                 else if (this.isLoop) this.current = 0;
//                 this.update();
//             },

//             prev() {
//                 if (this.current > 0) this.current--;
//                 else if (this.isLoop) this.current = this.slides.length - 1;
//                 this.update();
//             },

//             goTo(target) {
//                 if (typeof target === "number") {
//                     this.current = target;
//                 } else {
//                     const slide = document.getElementById(target);
//                     this.current = this.slides.indexOf(slide);
//                 }
//                 this.update();
//             },

//             /* ---------- drag / touch ---------- */
//             onStart(x) {
//                 this.isDragging = true;
//                 this.startX = x;
//                 this.track.style.transition = "none";
//                 this.wrapper.style.cursor = "grabbing";

//                 this.slides.forEach(s => {
//                     s.style.pointerEvents = "none";
//                     s.style.userSelect = "none";
//                     s.querySelectorAll("img").forEach(img => img.setAttribute("draggable", "false"));
//                 });

//                 this.stopAutoplay();
//             },

//             onMove(x) {
//                 if (!this.isDragging) return;
//                 const diff = this.startX - x;
//                 const sign = this.isRTL && !this.isVertical ? -1 : 1;

//                 this.track.style.transform = this.isVertical
//                     ? `translateY(calc(-${this.current * 100}% - ${diff}px))`
//                     : `translateX(calc(-${this.current * 100}% - ${diff * sign}px))`;
//             },

//             onEnd(x) {
//                 if (!this.isDragging) return;
//                 const diff = this.startX - x;

//                 this.track.style.transition = "";
//                 this.wrapper.style.cursor = "grab";
//                 this.isDragging = false;
//                 this.slides.forEach(s => {
//                     s.style.pointerEvents = "all";
//                     s.style.userSelect = "auto";
//                     s.querySelectorAll("img").forEach(img => img.setAttribute("draggable", "true"));
//                 });

//                 if (Math.abs(diff) > 50) {
//                     diff > 0 ? this.next() : this.prev();
//                 } else {
//                     this.update();
//                 }

//                 this.initAutoplay();
//             },

//             /* ---------- autoplay ---------- */

//             initAutoplay() {
//                 if (!this.autoplayDelay) return;
//                 this.autoplayTimer = setInterval(() => this.next(), this.autoplayDelay);
//             },

//             stopAutoplay() {
//                 if (this.autoplayTimer) clearInterval(this.autoplayTimer);
//             },

//             /* ---------- events ---------- */

//             bindEvents() {
//                 this.wrapper.style.cursor = "grab";

//                 this.nextArrow?.addEventListener("click", () => this.next());
//                 this.prevArrow?.addEventListener("click", () => this.prev());

//                 this.toggles.forEach(toggle => {
//                     toggle.addEventListener("click", () =>
//                         this.goTo(toggle.dataset.sliderId)
//                     );
//                 });

//                 // mouse
//                 this.wrapper.addEventListener("mousedown", e => this.onStart(e.clientX));
//                 window.addEventListener("mousemove", e => this.onMove(e.clientX));
//                 window.addEventListener("mouseup", e => this.onEnd(e.clientX));

//                 // touch
//                 this.wrapper.addEventListener("touchstart", e =>
//                     this.onStart(e.touches[0].clientX)
//                 );
//                 this.wrapper.addEventListener("touchmove", e =>
//                     this.onMove(e.touches[0].clientX)
//                 );
//                 this.wrapper.addEventListener("touchend", e =>
//                     this.onEnd(e.changedTouches[0].clientX)
//                 );

//                 // keyboard
//                 window.addEventListener("keydown", e => {
//                     if (e.key === "ArrowRight") this.isRTL ? this.prev() : this.next();
//                     if (e.key === "ArrowLeft") this.isRTL ? this.next() : this.prev();
//                 });
//             },

//             /* ---------- public api ---------- */

//             getCurrentIndex() {
//                 return this.current;
//             },

//             getCurrentSlide() {
//                 return this.slides[this.current];
//             },

//             destroy() {
//                 this.stopAutoplay();
//                 this.track.style.transform = "";
//             }
//         };

//         instance.init();
//         return instance;
//     }

//     /* global api */
//     next() {
//         this.instances.forEach(i => i.next());
//     }
//     prev() {
//         this.instances.forEach(i => i.prev());
//     }
//     goTo(v) {
//         this.instances.forEach(i => i.goTo(v));
//     }
// }

// new Slider();

class Slider {
    constructor(selector = ".slider") {
        this.instances = [];
        document.querySelectorAll(selector).forEach(slider => {
            this.instances.push(this.createInstance(slider));
        });
    }

    createInstance(slider) {
        const instance = {
            container: slider,
            wrapper: slider.querySelector(".slider-wrapper"),
            track: slider.querySelector(".slider-container"),
            slides: Array.from(slider.querySelectorAll(".slider-content")),
            toggles: slider.querySelectorAll(".slider-toggle"),
            nextArrow: slider.querySelector(".slider-arrow-next"),
            prevArrow: slider.querySelector(".slider-arrow-prev"),

            current: 0,
            startX: 0,
            startY: 0,
            isDragging: false,
            autoplayTimer: null,

            isVertical: false,
            isLoop: false,
            isRTL: false,
            autoplayDelay: null,

            init() {
                this.isVertical = this.wrapper.classList.contains("slider-column");
                this.isLoop = this.wrapper.classList.contains("slider-loop");
                this.isRTL = getComputedStyle(this.container).direction === "rtl";

                this.autoplayDelay = this.container.dataset.sliderTimer
                    ? parseInt(this.container.dataset.sliderTimer)
                    : null;

                const activeIndex = this.slides.findIndex(s => s.classList.contains("active"));
                this.current = activeIndex >= 0 ? activeIndex : 0;

                this.bindEvents();
                this.update();
                this.initAutoplay();
            },

            /* ---------- core ---------- */
            update() {
                let value = this.current * 100;
                if (!this.isVertical && this.isRTL) value *= -1;

                this.track.style.transform = this.isVertical
                    ? `translateY(-${value}%)`
                    : `translateX(-${value}%)`;

                this.slides.forEach(s => s.classList.remove("active"));
                this.slides[this.current].classList.add("active");

                this.toggles.forEach(t => t.classList.remove("active"));
                const t = this.container.querySelector(
                    `.slider-toggle[data-slider-id="${this.slides[this.current].id}"]`
                );
                t?.classList.add("active");

                this.updateArrows();
            },

            updateArrows() {
                if (!this.prevArrow || !this.nextArrow || this.isLoop) return;

                this.prevArrow.classList.toggle("disabled", this.current === 0);
                this.nextArrow.classList.toggle(
                    "disabled",
                    this.current === this.slides.length - 1
                );
            },

            next() {
                if (this.current < this.slides.length - 1) this.current++;
                else if (this.isLoop) this.current = 0;
                this.update();
            },

            prev() {
                if (this.current > 0) this.current--;
                else if (this.isLoop) this.current = this.slides.length - 1;
                this.update();
            },

            goTo(target) {
                if (typeof target === "number") {
                    this.current = target;
                } else {
                    const slide = document.getElementById(target);
                    this.current = this.slides.indexOf(slide);
                }
                this.update();
            },

            /* ---------- drag / touch ---------- */
            onStart(x, y) {
                this.isDragging = true;
                this.startX = x;
                this.startY = y;
                this.track.style.transition = "none";

                this.wrapper.classList.add("dragging");

                this.slides.forEach(s => {
                    s.querySelectorAll("img").forEach(img => img.setAttribute("draggable", "false"));
                });

                this.stopAutoplay();
            },

            onMove(x, y) {
                if (!this.isDragging) return;

                let diff;
                if (this.isVertical) {
                    diff = this.startY - y;
                    this.track.style.transform = `translateY(calc(-${this.current * 100}% - ${diff}px))`;
                } else {
                    diff = this.startX - x;
                    const sign = this.isRTL ? -1 : 1;
                    this.track.style.transform = `translateX(calc(-${this.current * 100}% - ${diff * sign}px))`;
                }
            },

            onEnd(x, y) {
                if (!this.isDragging) return;

                let diff;
                if (this.isVertical) {
                    diff = this.startY - y;
                } else {
                    diff = this.startX - x;
                }

                this.track.style.transition = "";
                this.isDragging = false;

                this.wrapper.classList.remove("dragging");

                this.slides.forEach(s => {
                    s.querySelectorAll("img").forEach(img => img.setAttribute("draggable", "false"));
                });

                if (Math.abs(diff) > 50) {
                    diff > 0 ? this.next() : this.prev();
                } else {
                    this.update();
                }

                this.initAutoplay();
            },

            /* ---------- autoplay ---------- */
            initAutoplay() {
                if (!this.autoplayDelay) return;
                this.autoplayTimer = setInterval(() => this.next(), this.autoplayDelay);
            },

            stopAutoplay() {
                if (this.autoplayTimer) clearInterval(this.autoplayTimer);
            },

            /* ---------- events ---------- */
            bindEvents() {
                this.nextArrow?.addEventListener("click", () => this.next());
                this.prevArrow?.addEventListener("click", () => this.prev());

                this.toggles.forEach(toggle => {
                    toggle.addEventListener("click", () =>
                        this.goTo(toggle.dataset.sliderId)
                    );
                });

                // mouse
                this.wrapper.addEventListener("mousedown", e => this.onStart(e.clientX, e.clientY));
                window.addEventListener("mousemove", e => this.onMove(e.clientX, e.clientY));
                window.addEventListener("mouseup", e => this.onEnd(e.clientX, e.clientY));

                // touch
                this.wrapper.addEventListener("touchstart", e =>
                    this.onStart(e.touches[0].clientX, e.touches[0].clientY)
                );
                this.wrapper.addEventListener("touchmove", e =>
                    this.onMove(e.touches[0].clientX, e.touches[0].clientY)
                );
                this.wrapper.addEventListener("touchend", e =>
                    this.onEnd(e.changedTouches[0].clientX, e.changedTouches[0].clientY)
                );

                // keyboard
                window.addEventListener("keydown", e => {
                    if (e.key === "ArrowRight") this.isRTL ? this.prev() : this.next();
                    if (e.key === "ArrowLeft") this.isRTL ? this.next() : this.prev();
                });
            },

            /* ---------- public api ---------- */
            getCurrentIndex() {
                return this.current;
            },

            getCurrentSlide() {
                return this.slides[this.current];
            },

            destroy() {
                this.stopAutoplay();
                this.track.style.transform = "";
            }
        };

        instance.init();
        return instance;
    }

    /* global api */
    next() {
        this.instances.forEach(i => i.next());
    }
    prev() {
        this.instances.forEach(i => i.prev());
    }
    goTo(v) {
        this.instances.forEach(i => i.goTo(v));
    }
}

new Slider();

// File: story\card\script.js
class Modal {
    constructor() {
        this.initialPositions = new Map()
        this.init()
    }

    init() {
        this.initToggles()
        this.initClose()
        this.initDraggable()
    }

    initToggles() {
        document.querySelectorAll(".modal-toggle").forEach(btn => {
            const id = btn.dataset.modalId
            btn.addEventListener("click", () => {
                const modal = document.getElementById(id)
                if (!modal) return
                console.log(modal);
                const modalContent = modal.querySelector(".modal-content")
                const container = modal.closest(".modal-container") || modal
                container.style.zIndex = 999;

                modal.style.display = "flex"
                modal.classList.remove("hide")
                modal.classList.add("show")

                modalContent.addEventListener("animationend", () => {
                    if (modal.classList.contains("modal-remember-position") && modal.dataset.position) {
                        try {
                            const { top, left } = JSON.parse(modal.dataset.position)
                            modalContent.style.position = "absolute"
                            modalContent.style.top = `${top}px`
                            modalContent.style.left = `${left}px`
                            return
                        } catch (e) { }
                    }

                    if (!this.initialPositions.has(modal)) {
                        const rect = modalContent.getBoundingClientRect()
                        const parentRect = container.getBoundingClientRect()

                        const top = rect.top - parentRect.top
                        const left = rect.left - parentRect.left

                        this.initialPositions.set(modal, { top, left })
                    }

                    const initial = this.initialPositions.get(modal)
                    if (initial) {
                        modalContent.style.position = "absolute"
                        modalContent.style.top = `${initial.top}px`
                        modalContent.style.left = `${initial.left}px`
                    }
                }, { once: true })
            })
        })
    }

    initClose() {
        document.querySelectorAll(".modal-close").forEach(btn => {
            btn.addEventListener("click", () => {
                const modal = btn.closest(".modal-container, .modal-draggable")
                if (!modal) return
                const modalContent = modal.querySelector(".modal-content")

                modal.classList.remove("show")
                modal.classList.add("hide")

                modal.addEventListener("animationend", () => {
                    if (!modal.classList.contains("hide")) return

                    if (!modal.classList.contains("modal-remember-position") && modalContent) {
                        const initial = this.initialPositions.get(modal)
                        if (initial) {
                            modalContent.style.top = `${initial.top}px`
                            modalContent.style.left = `${initial.left}px`
                        }
                    }

                    modal.style.display = "none"
                    modal.classList.remove("hide")
                }, { once: true })
            })
        })
    }

    initDraggable() {
        document.querySelectorAll(".modal-draggable .modal-content .modal-header").forEach(header => {
            let isDragging = false
            let offsetX = 0
            let offsetY = 0
            const modalContent = header.closest(".modal-content")
            const modalContainer = header.closest(".modal-draggable")
            const parent = modalContainer.closest(".modal-container") || modalContainer
            modalContainer.style.zIndex = 999

            header.addEventListener("mousedown", e => {
                if (e.target.classList.contains("modal-close") || e.target.tagName === "BUTTON") return

                isDragging = true
                modalContent.classList.add("dragging")

                const rect = modalContent.getBoundingClientRect()
                const parentRect = parent.getBoundingClientRect()

                modalContent.style.left = `${rect.left - parentRect.left}px`
                modalContent.style.top = `${rect.top - parentRect.top}px`
                modalContent.style.position = "absolute"
                modalContent.style.margin = "0"

                offsetX = e.clientX - rect.left
                offsetY = e.clientY - rect.top
            })

            document.addEventListener("mousemove", e => {
                if (!isDragging) return

                const parentRect = parent.getBoundingClientRect()
                let newLeft = e.clientX - parentRect.left - offsetX
                let newTop = e.clientY - parentRect.top - offsetY

                if (modalContainer.classList.contains("modal-bounds")) {
                    const modalRect = modalContent.getBoundingClientRect()
                    const maxLeft = parentRect.width - modalRect.width
                    const maxTop = parentRect.height - modalRect.height

                    if (newLeft < 0) newLeft = 0
                    if (newTop < 0) newTop = 0
                    if (newLeft > maxLeft) newLeft = maxLeft
                    if (newTop > maxTop) newTop = maxTop
                }

                modalContent.style.left = `${newLeft}px`
                modalContent.style.top = `${newTop}px`
            })

            document.addEventListener("mouseup", () => {
                if (!isDragging) return
                isDragging = false
                modalContent.classList.remove("dragging")

                if (modalContainer.classList.contains("modal-remember-position")) {
                    modalContainer.dataset.position = JSON.stringify({
                        top: parseFloat(modalContent.style.top),
                        left: parseFloat(modalContent.style.left)
                    })
                }
            })
        })
    }
}
new Modal()

// File: story\toggle\script.js


// File: summary-opinion\script.js


// File: unavailable-product\script.js


// File: variable-product\script.js


// File: weblog-card\script.js


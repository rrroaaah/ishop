// Mizoon Theme Scripts
// Auto-generated file


// File: article\script.js


// File: basic\script.js


// File: biography\script.js


// File: card-brand\script.js


// File: card-tooltip\script.js


// File: certificate-of-appreciation\script.js


// File: commodity-pack\script.js


// File: contact-us\script.js


// File: copy\script.js
class CopyAddress {
    constructor(selector = '.copy-address') {
      this.items = document.querySelectorAll(selector);
      this.init();
    }
  
    init() {
      this.items.forEach(wrapper => {
        const copyBtn = wrapper.querySelector('.copy-item');
        const urlEl = wrapper.querySelector('.site-url');
  
        if (!copyBtn || !urlEl) return;
  
        const url = window.location.href;
  
        urlEl.textContent = url;
  
        copyBtn.addEventListener('click', () => {
          this.copyToClipboard(url, copyBtn);
        });
      });
    }
  
    copyToClipboard(text, button) {
      navigator.clipboard.writeText(text).then(() => {
        this.onSuccess(button);
      }).catch(() => {
        this.onError(button);
      });
    }
  
  }
  
new CopyAddress();

// File: countdown\script.js
class Countdown {
  static UNITS = ['seconds', 'minutes', 'hours', 'days'];
  static DEFAULT_SEPARATOR = ':';
  static INTERVAL = 1000;

  constructor(element, options = {}) {
    this.element = element;
    this.separator = options.separator || Countdown.DEFAULT_SEPARATOR;
    this.parts = (element.dataset.countdown || '0').split(':').map(Number).reverse();
    this.unitCount = this.parts.length;
    this.totalSeconds = this.toSeconds(this.parts);
    this.timer = null;

    this.build();
    this.start();
  }

  // --- Helpers ---
  toSeconds([seconds = 0, minutes = 0, hours = 0, days = 0]) {
    return seconds + minutes * 60 + hours * 3600 + days * 86400;
  }

  fromSeconds(total) {
    const limits = [60, 60, 24, Infinity];
    return limits.map(limit => {
      const value = total % limit;
      total = Math.floor(total / limit);
      return value;
    });
  }

  createSeparator() {
    const sep = document.createElement('span');
    sep.className = 'countdown-separator';
    sep.textContent = this.separator;
    return sep;
  }

  createItem(value, unit) {
    const item = document.createElement('div');
    item.className = `countdown-item ${unit}`;
    String(value).padStart(2, '0').split('').forEach(digit => {
      const span = document.createElement('span');
      span.className = 'fields';
      span.textContent = digit;
      item.appendChild(span);
    });
    return item;
  }

  // --- Build DOM ---
  build() {
    this.element.innerHTML = '';
    this.parts.forEach((value, index) => {
      const unit = Countdown.UNITS[index];
      if (!unit) return;
      this.element.appendChild(this.createItem(value, unit));
      if (index < this.unitCount - 1) this.element.appendChild(this.createSeparator());
    });
  }

  // --- Update DOM ---
  update(values) {
    this.element.querySelectorAll('.countdown-item').forEach((item, index) => {
      String(values[index]).padStart(2, '0').split('').forEach((digit, i) => {
        item.querySelectorAll('.fields')[i].textContent = digit;
      });
    });
  }

  // --- Timer ---
  tick() {
    if (this.totalSeconds <= 0) {
      clearInterval(this.timer);
      return;
    }
    this.totalSeconds--;
    this.update(this.fromSeconds(this.totalSeconds));
  }

  start() {
    this.timer = setInterval(() => this.tick(), Countdown.INTERVAL);
  }

  pause() {
    clearInterval(this.timer);
    this.timer = null;
  }

  resume() {
    if (!this.timer) this.start();
  }
}

// Auto-init
document.addEventListener('DOMContentLoaded', () => {
  document.querySelectorAll('.countdown[data-countdown]').forEach(el => new Countdown(el));
});


// File: faq\script.js
class Accordion {
    constructor() {
        this.accordionItems = document.querySelectorAll('.accordion');
        this.init();
    }

    init() {
        this.accordionItems.forEach(item => {
            item.addEventListener('click', (event) => this.handleAccordionClick(event));
        });
    }

    handleAccordionClick(event) {
        const clickedItem = event.currentTarget;
        const parentElement = clickedItem.parentElement;
        const siblings = parentElement.querySelectorAll('.accordion');

        if (this.isIndependent(clickedItem)) {
            this.toggleAccordion(clickedItem);
            return;
        }

        this.closeOtherAccordions(siblings, clickedItem);
        this.toggleAccordion(clickedItem);
    }

    isIndependent(item) {
        return item.classList.contains('accordion-absolute');
    }

    toggleAccordion(item) {
        item.classList.toggle('active');
    }

    closeOtherAccordions(siblings, currentItem) {
        siblings.forEach(sibling => {
            if (sibling !== currentItem && !this.isIndependent(sibling)) {
                sibling.classList.remove('active');
            }
        });
    }
}

// Initialize accordion when DOM is loaded
new Accordion();

// File: feature-description-box\script.js


// File: logo-banner\script.js


// File: more-discounts-tooltip\script.js


// File: product-button-feature\script.js


// File: product-card\script.js


// File: product-category\script.js
const productsCategory = document.querySelectorAll(".product-category");

productsCategory.forEach(category => {
    category.addEventListener("click" , () => {
        productsCategory.forEach(active => active.classList.remove("active"));

        category.classList.add("active");
    });
});

// File: product-comment\script.js


// File: product-details\script.js


// File: product-gallery-image\script.js
class ProductHover {
    constructor(selector = '.product-gallery .slider-content') {
      this.items = document.querySelectorAll(selector);
      this.init();
    }
  
    init() {
      this.items.forEach(wrapper => {
        const img = wrapper.querySelector('img');
        if (!img) return;
  
        wrapper.addEventListener('mousemove', e => {
          this.onMove(e, wrapper, img);
        });
  
        wrapper.addEventListener('mouseleave', () => {
          this.onLeave(img);
        });
      });
    }
  
    onMove(e, wrapper, img) {
      const rect = wrapper.getBoundingClientRect();
      const x = ((e.clientX - rect.left) / rect.width) * 100;
      const y = ((e.clientY - rect.top) / rect.height) * 100;
  
      img.style.transformOrigin = `${x}% ${y}%`;
      img.style.transform = 'scale(2)';
    }
  
    onLeave(img) {
      img.style.transformOrigin = 'center';
      img.style.transform = 'scale(1)';
    }
}

new ProductHover();

// File: product-gallery-slider\script.js


// File: product-qa\script.js


// File: product-specifications\script.js


// File: progress\script.js
class ProgressBar {
    constructor() {
        this.init();
    }

    init() {
        document.querySelectorAll('.progress-bar').forEach(bar => {
            const percentage = bar.dataset.progressPercentage;
            const duration = bar.dataset.progressDuration;
            const delay = bar.dataset.progressDelay;

            if (percentage) {
                bar.style.setProperty('--percentage', percentage);
            }

            if (duration) {
                bar.style.setProperty('--progress-animation-duration', duration);
            }

            if (delay) {
                bar.style.setProperty('--progress-animation-delay', delay);
            }
        });
    }
}

new ProgressBar();

// File: rating-card\script.js


// File: return-conditions\script.js


// File: single-product-content\script.js
class SectionScroller {
    constructor(options) {
        this.upArrow = document.querySelector(options.upArrowSelector);
        this.downArrow = document.querySelector(options.downArrowSelector);
        this.titles = document.querySelectorAll(options.titleSelector);
        this.sections = options.sectionIds.map(id => document.getElementById(id));
        this.currentIndex = 0;

        this.init();
    }

    init() {
        this.updateTitle(this.currentIndex);
        this.bindEvents();
    }

    bindEvents() {
        this.upArrow.addEventListener("click", () => this.scrollToSection(this.currentIndex - 1));
        this.downArrow.addEventListener("click", () => this.scrollToSection(this.currentIndex + 1));

        window.addEventListener("scroll", () => this.onScroll());
    }

    updateTitle(index) {
        this.titles.forEach((h3, i) => h3.classList.toggle("active", i === index));
    }

    scrollToSection(index) {
        if (index < 0) index = 0;
        if (index >= this.sections.length) index = this.sections.length - 1;

        this.sections[index].scrollIntoView({ behavior: "smooth" });
        this.currentIndex = index;
        this.updateTitle(this.currentIndex);
    }

    onScroll() {
        const scrollPos = window.scrollY + window.innerHeight / 2;
        this.sections.forEach((section, idx) => {
            if (section.offsetTop <= scrollPos) {
                this.currentIndex = idx;
                this.updateTitle(this.currentIndex);
            }
        });
    }
}

document.addEventListener("DOMContentLoaded", () => {
    const scroller = new SectionScroller({
        upArrowSelector: ".arrow-controls .fa-angle-up",
        downArrowSelector: ".arrow-controls .fa-angle-down",
        titleSelector: ".slider-frame h3",
        sectionIds: ["description-link", "description-completed", "comented-link", "question-link"]
    });
});


// File: slider\script.js
class Slider {
    constructor(mainSliderSelector = null) {
        // Store all slider instances
        this.instances = [];
        
        if (mainSliderSelector) {
            // Single slider mode - create one instance
            const container = document.querySelector(mainSliderSelector);
            if (container) {
                this.instances.push(this.createSliderInstance(container));
            }
        } else {
            // Auto mode - find all .slider elements
            const containers = document.querySelectorAll(".slider");
            containers.forEach(container => {
                this.instances.push(this.createSliderInstance(container));
            });
        }
        
        // If no instances were created, log error
        if (this.instances.length === 0) {
            console.error('No slider containers found!');
            return;
        }
    }
    
    createSliderInstance(sliderContainer) {
        const instance = {
            // Elements
            container: sliderContainer,
            wrapper: sliderContainer.querySelector(".slider-wrapper"),
            slides: null,
            togglesContainer: null,
            toggles: null,
            sliderContainerInner: null,
            
            // Arrow navigation elements
            arrowsContainer: null,
            nextArrow: null,
            prevArrow: null,
            
            // Configuration
            isLoop: false,
            
            // State
            startX: 0,
            isDragging: false,
            currentIndex: 0,
            slideToggleMap: new Map(),
            
            // Methods
            init: function() {
                // Find elements
                this.slides = Array.from(this.wrapper.querySelectorAll(".slider-content"));
                this.togglesContainer = this.container.querySelector(".slider-toggles");
                this.toggles = this.togglesContainer ? this.togglesContainer.querySelectorAll(".slider-toggle") : [];
                this.sliderContainerInner = this.wrapper.querySelector(".slider-container");
                
                // Find arrow navigation elements
                this.arrowsContainer = this.container.querySelector(".slider-arrows");
                if (this.arrowsContainer) {
                    this.nextArrow = this.arrowsContainer.querySelector(".slider-arrow-next");
                    this.prevArrow = this.arrowsContainer.querySelector(".slider-arrow-prev");
                }
                
                // Configuration
                this.isLoop = this.wrapper.classList.contains("slider-loop");
                
                // State
                this.currentIndex = this.slides.findIndex((s) => s.classList.contains("active"));
                
                // Create slide to toggle mapping
                this.createSlideToggleMap();
                
                // Set initial state
                if (this.currentIndex !== -1) {
                    this.updateSlider(this.currentIndex);
                } else {
                    this.updateSlider(0);
                }
                
                // Bind event listeners
                this.bindEvents();
                
                // Set initial cursor
                this.wrapper.style.cursor = 'grab';
                
                // Update arrow states
                this.updateArrowStates();
            },
            
            createSlideToggleMap: function() {
                this.slideToggleMap.clear();
                
                this.toggles.forEach(toggle => {
                    const slideId = toggle.getAttribute('data-slider-id');
                    const slide = document.getElementById(slideId);
                    if (slide) {
                        this.slideToggleMap.set(toggle, slide);
                        this.slideToggleMap.set(slide, toggle);
                    }
                });
            },
            
            updateSlider: function(index) {
                if (this.isLoop) {
                    if (index < 0) index = this.slides.length - 1;
                    if (index >= this.slides.length) index = 0;
                } else {
                    if (index < 0 || index >= this.slides.length) return;
                }

                this.currentIndex = index;

                this.slides.forEach((slide, i) => {
                    slide.classList.remove("prev", "active", "next");

                    const diff = i - this.currentIndex;
                    slide.style.setProperty("--number", diff);

                    if (diff === 0) slide.classList.add("active");
                    else if (diff < 0) slide.classList.add("prev");
                    else slide.classList.add("next");
                });
                
                // Update toggles based on active slide
                this.updateToggles();
                
                // Update arrow states
                this.updateArrowStates();
            },
            
            updateToggles: function() {
                // Remove active class from all toggles
                this.toggles.forEach(toggle => {
                    toggle.classList.remove('active');
                });
                
                // Add active class to current toggle
                const currentSlide = this.slides[this.currentIndex];
                const currentToggle = this.slideToggleMap.get(currentSlide);
                if (currentToggle) {
                    currentToggle.classList.add('active');
                }
            },
            
            updateArrowStates: function() {
                if (!this.nextArrow || !this.prevArrow) return;
                
                // Remove disabled classes
                this.nextArrow.classList.remove('disabled');
                this.prevArrow.classList.remove('disabled');
                
                // Add disabled classes if not looping and at boundaries
                if (!this.isLoop) {
                    if (this.currentIndex === 0) {
                        this.prevArrow.classList.add('disabled');
                    }
                    if (this.currentIndex === this.slides.length - 1) {
                        this.nextArrow.classList.add('disabled');
                    }
                }
            },
            
            bindEvents: function() {
                // Thumbnail clicks - using data-slider-id mapping
                this.toggles.forEach((toggle) => {
                    toggle.addEventListener("click", () => {
                        const slideId = toggle.getAttribute('data-slider-id');
                        const slide = document.getElementById(slideId);
                        if (slide) {
                            const slideIndex = this.slides.indexOf(slide);
                            if (slideIndex !== -1) {
                                this.updateSlider(slideIndex);
                            }
                        }
                    });
                });

                // Arrow navigation clicks
                if (this.nextArrow) {
                    this.nextArrow.addEventListener("click", () => {
                        this.next();
                    });
                }
                
                if (this.prevArrow) {
                    this.prevArrow.addEventListener("click", () => {
                        this.prev();
                    });
                }

                // Touch events
                this.wrapper.addEventListener("touchstart", this.handleTouchStart.bind(this));
                this.wrapper.addEventListener("touchend", this.handleTouchEnd.bind(this));
                this.wrapper.addEventListener("touchmove", this.handleTouchMove.bind(this), { passive: false });

                // Mouse events
                this.wrapper.addEventListener("mousedown", this.handleMouseDown.bind(this));
                this.wrapper.addEventListener("mousemove", this.handleMouseMove.bind(this));
                this.wrapper.addEventListener("mouseup", this.handleMouseUp.bind(this));
                this.wrapper.addEventListener("mouseleave", this.handleMouseLeave.bind(this));
                
                // Global mouse up
                document.addEventListener("mouseup", this.handleGlobalMouseUp.bind(this));
            },
            
            // Touch handlers
            handleTouchStart: function(e) {
                this.startX = e.touches[0].clientX;
            },
            
            handleTouchEnd: function(e) {
                const endX = e.changedTouches[0].clientX;
                const diffX = this.startX - endX;

                if (Math.abs(diffX) > 50) {
                    diffX > 0 
                        ? this.updateSlider(this.currentIndex + 1) 
                        : this.updateSlider(this.currentIndex - 1);
                }
            },
            
            handleTouchMove: function(e) {
                if (!this.isDragging) return;
                e.preventDefault();
            },
            
            // Mouse handlers
            handleMouseDown: function(e) {
                this.isDragging = true;
                this.startX = e.clientX;
                this.wrapper.style.cursor = "grabbing";
                e.preventDefault();
            },
            
            handleMouseMove: function(e) {
                if (!this.isDragging) return;
                e.preventDefault();

                const currentX = e.clientX;
                const diffX = this.startX - currentX;

                const transform = `translateX(calc(-${this.currentIndex * 100}% - ${diffX}px))`;
                if (this.sliderContainerInner) {
                    this.sliderContainerInner.style.transform = transform;
                }
            },
            
            handleMouseUp: function(e) {
                if (!this.isDragging) return;

                const endX = e.clientX;
                const diffX = this.startX - endX;

                this.resetTransform();

                if (Math.abs(diffX) > 50) {
                    diffX > 0 
                        ? this.updateSlider(this.currentIndex + 1) 
                        : this.updateSlider(this.currentIndex - 1);
                }

                this.isDragging = false;
                this.wrapper.style.cursor = "grab";
            },
            
            handleMouseLeave: function() {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.wrapper.style.cursor = "grab";
                    this.resetTransform();
                }
            },
            
            handleGlobalMouseUp: function() {
                if (this.isDragging) {
                    this.isDragging = false;
                    this.wrapper.style.cursor = "grab";
                    this.resetTransform();
                }
            },
            
            // Utility methods
            resetTransform: function() {
                if (this.sliderContainerInner) {
                    this.sliderContainerInner.style.transform = `translateX(-${this.currentIndex * 100}%)`;
                }
            },
            
            // Public methods
            next: function() {
                this.updateSlider(this.currentIndex + 1);
            },
            
            prev: function() {
                this.updateSlider(this.currentIndex - 1);
            },
            
            goTo: function(slideId) {
                // Can accept either slide id or index
                if (typeof slideId === 'string') {
                    const slide = document.getElementById(slideId);
                    if (slide) {
                        const slideIndex = this.slides.indexOf(slide);
                        if (slideIndex !== -1) {
                            this.updateSlider(slideIndex);
                        }
                    }
                } else {
                    this.updateSlider(slideId);
                }
            },
            
            // Get current slide info
            getCurrentSlide: function() {
                return this.slides[this.currentIndex];
            },
            
            getCurrentSlideId: function() {
                const currentSlide = this.getCurrentSlide();
                return currentSlide ? currentSlide.id : null;
            },
            
            // Destroy method for cleanup
            destroy: function() {
                // Remove event listeners
                this.wrapper.removeEventListener("touchstart", this.handleTouchStart);
                this.wrapper.removeEventListener("touchend", this.handleTouchEnd);
                this.wrapper.removeEventListener("touchmove", this.handleTouchMove);
                this.wrapper.removeEventListener("mousedown", this.handleMouseDown);
                this.wrapper.removeEventListener("mousemove", this.handleMouseMove);
                this.wrapper.removeEventListener("mouseup", this.handleMouseUp);
                this.wrapper.removeEventListener("mouseleave", this.handleMouseLeave);
                document.removeEventListener("mouseup", this.handleGlobalMouseUp);
                
                // Remove arrow event listeners
                if (this.nextArrow) {
                    this.nextArrow.removeEventListener("click", this.next);
                }
                if (this.prevArrow) {
                    this.prevArrow.removeEventListener("click", this.prev);
                }
                
                // Reset styles
                this.wrapper.style.cursor = '';
                if (this.sliderContainerInner) {
                    this.sliderContainerInner.style.transform = '';
                }
                
                // Clear map
                this.slideToggleMap.clear();
            }
        };
        
        // Initialize the instance
        instance.init();
        
        return instance;
    }
    
    // Public methods that operate on all instances
    next() {
        this.instances.forEach(instance => instance.next());
    }
    
    prev() {
        this.instances.forEach(instance => instance.prev());
    }
    
    goTo(slideId) {
        this.instances.forEach(instance => instance.goTo(slideId));
    }
    
    // Get specific instance by index
    getInstance(index) {
        return this.instances[index] || null;
    }
    
    // Get all instances
    getAllInstances() {
        return this.instances;
    }
    
    // Destroy all instances
    destroy() {
        this.instances.forEach(instance => instance.destroy());
        this.instances = [];
    }
}

new Slider();

// File: story\card\script.js
class Modal {
    constructor() {
        this.initialPositions = new Map()
        this.init()
    }

    init() {
        this.initToggles()
        this.initClose()
        this.initDraggable()
    }

    initToggles() {
        document.querySelectorAll(".modal-toggle").forEach(btn => {
            const id = btn.dataset.modalId
            btn.addEventListener("click", () => {
                const modal = document.getElementById(id)
                if (!modal) return
                console.log(modal);
                const modalContent = modal.querySelector(".modal-content")
                const container = modal.closest(".modal-container") || modal
                container.style.zIndex = 999;

                modal.style.display = "flex"
                modal.classList.remove("hide")
                modal.classList.add("show")

                modalContent.addEventListener("animationend", () => {
                    if (modal.classList.contains("modal-remember-position") && modal.dataset.position) {
                        try {
                            const { top, left } = JSON.parse(modal.dataset.position)
                            modalContent.style.position = "absolute"
                            modalContent.style.top = `${top}px`
                            modalContent.style.left = `${left}px`
                            return
                        } catch (e) { }
                    }

                    if (!this.initialPositions.has(modal)) {
                        const rect = modalContent.getBoundingClientRect()
                        const parentRect = container.getBoundingClientRect()

                        const top = rect.top - parentRect.top
                        const left = rect.left - parentRect.left

                        this.initialPositions.set(modal, { top, left })
                    }

                    const initial = this.initialPositions.get(modal)
                    if (initial) {
                        modalContent.style.position = "absolute"
                        modalContent.style.top = `${initial.top}px`
                        modalContent.style.left = `${initial.left}px`
                    }
                }, { once: true })
            })
        })
    }

    initClose() {
        document.querySelectorAll(".modal-close").forEach(btn => {
            btn.addEventListener("click", () => {
                const modal = btn.closest(".modal-container, .modal-draggable")
                if (!modal) return
                const modalContent = modal.querySelector(".modal-content")

                modal.classList.remove("show")
                modal.classList.add("hide")

                modal.addEventListener("animationend", () => {
                    if (!modal.classList.contains("hide")) return

                    if (!modal.classList.contains("modal-remember-position") && modalContent) {
                        const initial = this.initialPositions.get(modal)
                        if (initial) {
                            modalContent.style.top = `${initial.top}px`
                            modalContent.style.left = `${initial.left}px`
                        }
                    }

                    modal.style.display = "none"
                    modal.classList.remove("hide")
                }, { once: true })
            })
        })
    }

    initDraggable() {
        document.querySelectorAll(".modal-draggable .modal-content .modal-header").forEach(header => {
            let isDragging = false
            let offsetX = 0
            let offsetY = 0
            const modalContent = header.closest(".modal-content")
            const modalContainer = header.closest(".modal-draggable")
            const parent = modalContainer.closest(".modal-container") || modalContainer
            modalContainer.style.zIndex = 999

            header.addEventListener("mousedown", e => {
                if (e.target.classList.contains("modal-close") || e.target.tagName === "BUTTON") return

                isDragging = true
                modalContent.classList.add("dragging")

                const rect = modalContent.getBoundingClientRect()
                const parentRect = parent.getBoundingClientRect()

                modalContent.style.left = `${rect.left - parentRect.left}px`
                modalContent.style.top = `${rect.top - parentRect.top}px`
                modalContent.style.position = "absolute"
                modalContent.style.margin = "0"

                offsetX = e.clientX - rect.left
                offsetY = e.clientY - rect.top
            })

            document.addEventListener("mousemove", e => {
                if (!isDragging) return

                const parentRect = parent.getBoundingClientRect()
                let newLeft = e.clientX - parentRect.left - offsetX
                let newTop = e.clientY - parentRect.top - offsetY

                if (modalContainer.classList.contains("modal-bounds")) {
                    const modalRect = modalContent.getBoundingClientRect()
                    const maxLeft = parentRect.width - modalRect.width
                    const maxTop = parentRect.height - modalRect.height

                    if (newLeft < 0) newLeft = 0
                    if (newTop < 0) newTop = 0
                    if (newLeft > maxLeft) newLeft = maxLeft
                    if (newTop > maxTop) newTop = maxTop
                }

                modalContent.style.left = `${newLeft}px`
                modalContent.style.top = `${newTop}px`
            })

            document.addEventListener("mouseup", () => {
                if (!isDragging) return
                isDragging = false
                modalContent.classList.remove("dragging")

                if (modalContainer.classList.contains("modal-remember-position")) {
                    modalContainer.dataset.position = JSON.stringify({
                        top: parseFloat(modalContent.style.top),
                        left: parseFloat(modalContent.style.left)
                    })
                }
            })
        })
    }
}
new Modal()

// File: story\toggle\script.js


// File: summary-opinion\script.js


// File: weblog-card\script.js


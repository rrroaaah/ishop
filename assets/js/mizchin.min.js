// Mizoon Theme Scripts
// Auto-generated file


// File: article\script.js


// File: basic\script.js


// File: biography\script.js


// File: card-tooltip\script.js


// File: certificate-of-appreciation\script.js


// File: contact-us\script.js


// File: faq\script.js
class Accordion {
    constructor() {
        this.accordionItems = document.querySelectorAll('.accordion');
        this.init();
    }

    init() {
        this.accordionItems.forEach(item => {
            item.addEventListener('click', (event) => this.handleAccordionClick(event));
        });
    }

    handleAccordionClick(event) {
        const clickedItem = event.currentTarget;
        const parentElement = clickedItem.parentElement;
        const siblings = parentElement.querySelectorAll('.accordion');

        if (this.isIndependent(clickedItem)) {
            this.toggleAccordion(clickedItem);
            return;
        }

        this.closeOtherAccordions(siblings, clickedItem);
        this.toggleAccordion(clickedItem);
    }

    isIndependent(item) {
        return item.classList.contains('accordion-absolute');
    }

    toggleAccordion(item) {
        item.classList.toggle('active');
    }

    closeOtherAccordions(siblings, currentItem) {
        siblings.forEach(sibling => {
            if (sibling !== currentItem && !this.isIndependent(sibling)) {
                sibling.classList.remove('active');
            }
        });
    }
}

// Initialize accordion when DOM is loaded
new Accordion();

// File: feature-description-box\script.js


// File: logo-banner\script.js


// File: product-button-feature\script.js


// File: product-card\script.js


// File: product-category\script.js
const productsCategory = document.querySelectorAll(".product-category");

productsCategory.forEach(category => {
    category.addEventListener("click" , () => {
        productsCategory.forEach(active => active.classList.remove("active"));

        category.classList.add("active");
    });
});

// File: product-comment\script.js


// File: product-details\script.js


// File: product-gallery-slider\script.js


// File: product-qa\script.js


// File: product-specifications\script.js


// File: progress\script.js
class ProgressBar {
    constructor() {
        this.init();
    }

    init() {
        document.querySelectorAll('.progress-bar').forEach(bar => {
            const percentage = bar.dataset.progressPercentage;
            const duration = bar.dataset.progressDuration;
            const delay = bar.dataset.progressDelay;

            if (percentage) {
                bar.style.setProperty('--percentage', percentage);
            }

            if (duration) {
                bar.style.setProperty('--progress-animation-duration', duration);
            }

            if (delay) {
                bar.style.setProperty('--progress-animation-delay', delay);
            }
        });
    }
}

new ProgressBar();

// File: rating-card\script.js


// File: return-conditions\script.js


// File: slider\script.js
class Slider {
    // Configuration constants
    static THRESHOLD = 50;
    static TRANSITION_DURATION = 300;
    
    constructor(mainSliderSelector = null) {
        this.instances = [];
        this.initSliders(mainSliderSelector);
    }
    
    initSliders(selector) {
        const containers = selector 
            ? [document.querySelector(selector)].filter(Boolean)
            : Array.from(document.querySelectorAll(".slider"));
            
        containers.forEach(container => {
            this.instances.push(new SliderInstance(container));
        });
        
        if (this.instances.length === 0) {
            console.warn('No slider containers found!');
        }
    }
    
    // Public API methods
    next() { this.instances.forEach(instance => instance.next()); }
    prev() { this.instances.forEach(instance => instance.prev()); }
    goTo(slideId) { this.instances.forEach(instance => instance.goTo(slideId)); }
    getInstance(index) { return this.instances[index] || null; }
    getAllInstances() { return [...this.instances]; }
    destroy() { 
        this.instances.forEach(instance => instance.destroy());
        this.instances = [];
    }
}

class SliderInstance {
    constructor(container) {
        // Core elements
        this.container = container;
        this.wrapper = container.querySelector(".slider-wrapper");
        this.sliderContainer = this.wrapper?.querySelector(".slider-content");
        
        // Configuration
        this.config = this.getConfig();
        
        // State
        this.state = {
            currentIndex: 0,
            isDragging: false,
            startPos: { x: 0, y: 0 },
            currentPos: { x: 0, y: 0 }
        };
        
        // Elements collections
        this.elements = this.getElements();
        
        // Initialize
        this.init();
    }
    
    getConfig() {
        return {
            isLoop: this.wrapper?.classList.contains("slider-loop") || false,
            isVertical: this.wrapper?.classList.contains("slider-column") || false,
            axis: this.wrapper?.classList.contains("slider-column") ? 'y' : 'x'
        };
    }
    
    getElements() {
        return {
            slides: Array.from(this.wrapper?.querySelectorAll(".slider-content") || []),
            toggles: Array.from(this.container?.querySelectorAll(".slider-toggle") || []),
            arrows: {
                next: this.container?.querySelector(".slider-arrow-next"),
                prev: this.container?.querySelector(".slider-arrow-prev")
            }
        };
    }
    
    init() {
        if (!this.wrapper || !this.sliderContainer || this.elements.slides.length === 0) {
            console.error('Invalid slider structure');
            return;
        }
        
        this.setupInitialState();
        this.setupEventListeners();
        this.updateUI();
    }
    
    setupInitialState() {
        // Find initial active slide
        const activeIndex = this.elements.slides.findIndex(slide => 
            slide.classList.contains("active")
        );
        this.state.currentIndex = activeIndex !== -1 ? activeIndex : 0;
        
        // Setup cursor
        this.wrapper.style.cursor = 'grab';
        
        // Setup slide-toggle mapping
        this.createSlideToggleMap();
    }
    
    createSlideToggleMap() {
        this.slideToggleMap = new Map();
        
        this.elements.toggles.forEach(toggle => {
            const slideId = toggle.dataset.sliderId;
            const slide = document.getElementById(slideId);
            if (slide) {
                this.slideToggleMap.set(toggle, slide);
                this.slideToggleMap.set(slide, toggle);
            }
        });
    }
    
    setupEventListeners() {
        // Touch events
        this.wrapper.addEventListener("touchstart", this.handleStart.bind(this));
        this.wrapper.addEventListener("touchend", this.handleEnd.bind(this));
        this.wrapper.addEventListener("touchmove", this.handleMove.bind(this), { passive: false });
        
        // Mouse events
        this.wrapper.addEventListener("mousedown", this.handleStart.bind(this));
        this.wrapper.addEventListener("mousemove", this.handleMove.bind(this));
        this.wrapper.addEventListener("mouseup", this.handleEnd.bind(this));
        this.wrapper.addEventListener("mouseleave", this.handleLeave.bind(this));
        
        // Global events
        document.addEventListener("mouseup", this.handleGlobalEnd.bind(this));
        
        // Navigation events
        this.setupNavigationEvents();
    }
    
    setupNavigationEvents() {
        // Toggle clicks
        this.elements.toggles.forEach(toggle => {
            toggle.addEventListener("click", () => {
                const slideId = toggle.dataset.sliderId;
                const slide = document.getElementById(slideId);
                if (slide) {
                    const index = this.elements.slides.indexOf(slide);
                    this.goToSlide(index);
                }
            });
        });
        
        // Arrow clicks
        this.elements.arrows.next?.addEventListener("click", () => this.next());
        this.elements.arrows.prev?.addEventListener("click", () => this.prev());
    }
    
    // Unified event handlers
    handleStart(e) {
        this.state.isDragging = true;
        this.state.startPos = this.getPosition(e);
        this.wrapper.style.cursor = "grabbing";
        e.preventDefault();
    }
    
    handleMove(e) {
        if (!this.state.isDragging) return;
        e.preventDefault();
        
        this.state.currentPos = this.getPosition(e);
        this.updateDragTransform();
    }
    
    handleEnd(e) {
        if (!this.state.isDragging) return;
        
        const diff = this.calculateDragDistance();
        this.resetTransform();
        
        if (Math.abs(diff) > Slider.THRESHOLD) {
            if (diff > 0) {
                this.next();
            } else {
                this.prev();
            }
        }
        
        this.state.isDragging = false;
        this.wrapper.style.cursor = "grab";
    }
    
    handleLeave() {
        if (this.state.isDragging) {
            this.state.isDragging = false;
            this.wrapper.style.cursor = "grab";
            this.resetTransform();
        }
    }
    
    handleGlobalEnd() {
        if (this.state.isDragging) {
            this.state.isDragging = false;
            this.wrapper.style.cursor = "grab";
            this.resetTransform();
        }
    }
    
    // Position utilities
    getPosition(e) {
        if (e.touches) {
            return {
                x: e.touches[0].clientX,
                y: e.touches[0].clientY
            };
        }
        return {
            x: e.clientX,
            y: e.clientY
        };
    }
    
    calculateDragDistance() {
        const { startPos, currentPos } = this.state;
        return this.config.isVertical 
            ? startPos.y - currentPos.y
            : startPos.x - currentPos.x;
    }
    
    // Transform methods
    updateDragTransform() {
        const diff = this.calculateDragDistance();
        const baseTransform = this.getBaseTransform();
        const dragTransform = this.config.isVertical 
            ? `translateY(${-diff}px)`
            : `translateX(${-diff}px)`;
            
        this.sliderContainer.style.transform = `${baseTransform} ${dragTransform}`;
    }
    
    resetTransform() {
        this.sliderContainer.style.transform = this.getBaseTransform();
    }
    
    getBaseTransform() {
        const { currentIndex } = this.state;
        return this.config.isVertical 
            ? `translateY(-${currentIndex * 100}%)`
            : `translateX(-${currentIndex * 100}%)`;
    }
    
    // Navigation methods
    next() {
        this.goToSlide(this.state.currentIndex + 1);
    }
    
    prev() {
        this.goToSlide(this.state.currentIndex - 1);
    }
    
    goTo(slideId) {
        if (typeof slideId === 'string') {
            const slide = document.getElementById(slideId);
            if (slide) {
                const index = this.elements.slides.indexOf(slide);
                this.goToSlide(index);
            }
        } else {
            this.goToSlide(slideId);
        }
    }
    
    goToSlide(index) {
        const slidesLength = this.elements.slides.length;
        let targetIndex = index;
        
        // Handle loop boundaries
        if (this.config.isLoop) {
            if (index < 0) targetIndex = slidesLength - 1;
            if (index >= slidesLength) targetIndex = 0;
        } else {
            if (index < 0 || index >= slidesLength) return;
        }
        
        this.state.currentIndex = targetIndex;
        this.updateUI();
    }
    
    // UI updates
    updateUI() {
        this.updateSlides();
        this.updateToggles();
        this.updateArrows();
        this.resetTransform();
    }
    
    updateSlides() {
        this.elements.slides.forEach((slide, index) => {
            slide.classList.remove("prev", "active", "next");
            
            const diff = index - this.state.currentIndex;
            slide.style.setProperty("--number", diff);
            
            if (diff === 0) {
                slide.classList.add("active");
            } else if (diff < 0) {
                slide.classList.add("prev");
            } else {
                slide.classList.add("next");
            }
        });
    }
    
    updateToggles() {
        this.elements.toggles.forEach(toggle => {
            toggle.classList.remove('active');
        });
        
        const currentSlide = this.elements.slides[this.state.currentIndex];
        const currentToggle = this.slideToggleMap?.get(currentSlide);
        if (currentToggle) {
            currentToggle.classList.add('active');
        }
    }
    
    updateArrows() {
        const { next, prev } = this.elements.arrows;
        if (!next || !prev) return;
        
        next.classList.remove('disabled');
        prev.classList.remove('disabled');
        
        if (!this.config.isLoop) {
            if (this.state.currentIndex === 0) {
                prev.classList.add('disabled');
            }
            if (this.state.currentIndex === this.elements.slides.length - 1) {
                next.classList.add('disabled');
            }
        }
    }
    
    // Public methods
    getCurrentSlide() {
        return this.elements.slides[this.state.currentIndex];
    }
    
    getCurrentSlideId() {
        const slide = this.getCurrentSlide();
        return slide?.id || null;
    }
    
    // Cleanup
    destroy() {
        // Remove all event listeners
        this.wrapper.removeEventListener("touchstart", this.handleStart);
        this.wrapper.removeEventListener("touchend", this.handleEnd);
        this.wrapper.removeEventListener("touchmove", this.handleMove);
        this.wrapper.removeEventListener("mousedown", this.handleStart);
        this.wrapper.removeEventListener("mousemove", this.handleMove);
        this.wrapper.removeEventListener("mouseup", this.handleEnd);
        this.wrapper.removeEventListener("mouseleave", this.handleLeave);
        document.removeEventListener("mouseup", this.handleGlobalEnd);
        
        // Remove navigation listeners
        this.elements.toggles.forEach(toggle => {
            toggle.removeEventListener("click", this.handleToggleClick);
        });
        this.elements.arrows.next?.removeEventListener("click", this.next);
        this.elements.arrows.prev?.removeEventListener("click", this.prev);
        
        // Reset styles
        this.wrapper.style.cursor = '';
        this.sliderContainer.style.transform = '';
        
        // Clear references
        this.slideToggleMap?.clear();
    }
}

// Auto-initialize
// document.addEventListener('DOMContentLoaded', () => {
    // window.slider = 
    new Slider();
// });

// File: story\card\script.js
class Modal {
    constructor() {
        this.initialPositions = new Map()
        this.init()
    }

    init() {
        this.initToggles()
        this.initClose()
        this.initDraggable()
    }

    initToggles() {
        document.querySelectorAll(".modal-toggle").forEach(btn => {
            const id = btn.dataset.modalId
            btn.addEventListener("click", () => {
                const modal = document.getElementById(id)
                if (!modal) return
                console.log(modal);
                const modalContent = modal.querySelector(".modal-content")
                const container = modal.closest(".modal-container") || modal
                container.style.zIndex = 999;

                modal.style.display = "flex"
                modal.classList.remove("hide")
                modal.classList.add("show")

                modalContent.addEventListener("animationend", () => {
                    if (modal.classList.contains("modal-remember-position") && modal.dataset.position) {
                        try {
                            const { top, left } = JSON.parse(modal.dataset.position)
                            modalContent.style.position = "absolute"
                            modalContent.style.top = `${top}px`
                            modalContent.style.left = `${left}px`
                            return
                        } catch (e) { }
                    }

                    if (!this.initialPositions.has(modal)) {
                        const rect = modalContent.getBoundingClientRect()
                        const parentRect = container.getBoundingClientRect()

                        const top = rect.top - parentRect.top
                        const left = rect.left - parentRect.left

                        this.initialPositions.set(modal, { top, left })
                    }

                    const initial = this.initialPositions.get(modal)
                    if (initial) {
                        modalContent.style.position = "absolute"
                        modalContent.style.top = `${initial.top}px`
                        modalContent.style.left = `${initial.left}px`
                    }
                }, { once: true })
            })
        })
    }

    initClose() {
        document.querySelectorAll(".modal-close").forEach(btn => {
            btn.addEventListener("click", () => {
                const modal = btn.closest(".modal-container, .modal-draggable")
                if (!modal) return
                const modalContent = modal.querySelector(".modal-content")

                modal.classList.remove("show")
                modal.classList.add("hide")

                modal.addEventListener("animationend", () => {
                    if (!modal.classList.contains("hide")) return

                    if (!modal.classList.contains("modal-remember-position") && modalContent) {
                        const initial = this.initialPositions.get(modal)
                        if (initial) {
                            modalContent.style.top = `${initial.top}px`
                            modalContent.style.left = `${initial.left}px`
                        }
                    }

                    modal.style.display = "none"
                    modal.classList.remove("hide")
                }, { once: true })
            })
        })
    }

    initDraggable() {
        document.querySelectorAll(".modal-draggable .modal-content .modal-header").forEach(header => {
            let isDragging = false
            let offsetX = 0
            let offsetY = 0
            const modalContent = header.closest(".modal-content")
            const modalContainer = header.closest(".modal-draggable")
            const parent = modalContainer.closest(".modal-container") || modalContainer
            modalContainer.style.zIndex = 999

            header.addEventListener("mousedown", e => {
                if (e.target.classList.contains("modal-close") || e.target.tagName === "BUTTON") return

                isDragging = true
                modalContent.classList.add("dragging")

                const rect = modalContent.getBoundingClientRect()
                const parentRect = parent.getBoundingClientRect()

                modalContent.style.left = `${rect.left - parentRect.left}px`
                modalContent.style.top = `${rect.top - parentRect.top}px`
                modalContent.style.position = "absolute"
                modalContent.style.margin = "0"

                offsetX = e.clientX - rect.left
                offsetY = e.clientY - rect.top
            })

            document.addEventListener("mousemove", e => {
                if (!isDragging) return

                const parentRect = parent.getBoundingClientRect()
                let newLeft = e.clientX - parentRect.left - offsetX
                let newTop = e.clientY - parentRect.top - offsetY

                if (modalContainer.classList.contains("modal-bounds")) {
                    const modalRect = modalContent.getBoundingClientRect()
                    const maxLeft = parentRect.width - modalRect.width
                    const maxTop = parentRect.height - modalRect.height

                    if (newLeft < 0) newLeft = 0
                    if (newTop < 0) newTop = 0
                    if (newLeft > maxLeft) newLeft = maxLeft
                    if (newTop > maxTop) newTop = maxTop
                }

                modalContent.style.left = `${newLeft}px`
                modalContent.style.top = `${newTop}px`
            })

            document.addEventListener("mouseup", () => {
                if (!isDragging) return
                isDragging = false
                modalContent.classList.remove("dragging")

                if (modalContainer.classList.contains("modal-remember-position")) {
                    modalContainer.dataset.position = JSON.stringify({
                        top: parseFloat(modalContent.style.top),
                        left: parseFloat(modalContent.style.left)
                    })
                }
            })
        })
    }
}
new Modal()

// File: story\toggle\script.js


// File: summary-opinion\script.js


// File: weblog-card\script.js

